/**
 * Created by George Frick on 2/5/2017.
 */
var InputMaskModel = (function () {
    function InputMaskModel(maskPattern) {
        this.originalStringPattern = maskPattern;
        this.dividerCharacterSet = this.extractDividers(maskPattern);
    }
    Object.defineProperty(InputMaskModel.prototype, "originalPattern", {
        get: function () {
            return this.originalStringPattern;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputMaskModel.prototype, "dividerCharSet", {
        get: function () {
            return this.dividerCharacterSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputMaskModel.prototype, "placeHolderCount", {
        /**
         * Count the number of place holder values in the original pattern.
         * @returns {number}
         */
        get: function () {
            return (this.originalPattern.match(/\*/g) || []).length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an array representing all of the placeholder characters used
     * in the pattern. Currently this is anything not "$" and at least ["_"]
     * @param originalPattern
     * @returns {string[]}
     */
    InputMaskModel.prototype.extractDividers = function (originalPattern) {
        var dividers = originalPattern.replace(/\*/g, "").split("");
        //  dividers.push("_");
        return dividers;
    };
    /**
     * Is a given character a divider character?
     * @param character
     * @returns {boolean}
     */
    InputMaskModel.prototype.isDivider = function (character) {
        for (var dividerSetLoop = 0; dividerSetLoop < this.dividerCharSet.length; dividerSetLoop++) {
            if (character === this.dividerCharSet[dividerSetLoop]) {
                return true;
            }
        }
        return false;
    };
    Object.defineProperty(InputMaskModel.prototype, "maskedPattern", {
        /**
         * will turn X$$$X => X{0}{1}{2}X
         * @param patternString
         * @returns  X$$$X => X{0}{1}{2}X
         */
        get: function () {
            var generatedPattern = this.originalPattern;
            for (var patternIndex = 0; patternIndex < this.placeHolderCount; patternIndex++) {
                generatedPattern = generatedPattern.replace(/\*/, "{" + patternIndex + "}");
            }
            return generatedPattern;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Given a non-masked value; use the maskedPattern to create a masked value.
     * @param nonMaskedValue
     * @returns {string}
     */
    InputMaskModel.prototype.maskValue = function (nonMaskedValue) {
        var formattedString = this.maskedPattern;
        var replacement;
        var inputValue = nonMaskedValue || "";
        inputValue = this.unmaskValue(inputValue);
        for (var i = 0; i < this.placeHolderCount; i++) {
            replacement = inputValue.charAt(i) || "_";
            formattedString = formattedString.replace("{" + i + "}", replacement);
        }
        return formattedString;
    };
    /**
     * This is the current value when dividers are removed
     * @returns 9-5_1 => 951
     */
    InputMaskModel.prototype.unmaskValue = function (inputValue) {
        if (!inputValue) {
            return "";
        }
        var modelValue = inputValue;
        for (var dividerIndex = 0; dividerIndex < this.dividerCharSet.length; dividerIndex++) {
            while (modelValue.indexOf(this.dividerCharSet[dividerIndex]) > -1) {
                modelValue = modelValue.replace(this.dividerCharSet[dividerIndex], "");
            }
        }
        return modelValue.replace(/_/g, "");
    };
    /**
     * This is the current value when place holders are removed
     * @returns 9-5_ => 9-5
     */
    InputMaskModel.prototype.realValue = function (inputValue) {
        if (!inputValue || this.unmaskValue(inputValue) === "") {
            return "";
        }
        else {
            return inputValue.replace(/[*_]/g, "");
        }
    };
    InputMaskModel.prototype.getNextCaretPosition = function (viewValue, currentCaretPosition) {
        // Cursor can always be at 0.
        if (currentCaretPosition <= 0) {
            return 0;
        }
        // Cursor can't be positioned after a spacer.
        var firstSpacer = viewValue.indexOf("_");
        if (firstSpacer >= 0 && firstSpacer < currentCaretPosition) {
            return firstSpacer;
        }
        // Cursor
        while (this.isDivider(viewValue.charAt(currentCaretPosition))) {
            currentCaretPosition++;
        }
        return currentCaretPosition;
    };
    return InputMaskModel;
}());
export { InputMaskModel };
